// This is a Souffle Datalog file that processes .facts files emitted by the
// Souffle.emitRelations function (see ./Souffle/Basic.lean)

.type Name <: symbol
.type FVarId <: symbol
.type Hash <: unsigned
.type Nat <: unsigned // max 2^32
.type NatStr <: symbol

// These are used to associate Module and ModuleImport to Decl's
// (Not used yet)
.decl Module (modIdx: unsigned, modName: Name)
.input Module
.printsize Module

.decl ModuleImport (modName: Name, importName: Name)
.input ModuleImport
.printsize ModuleImport

// Param
.decl Param   (paramId: Hash, fvarId: FVarId, binderName: Name, typeId: Hash) choice-domain (paramId)
.input Param
.printsize Param

// Arg
.decl ArgErased (argId: Hash) choice-domain (argId)
.input ArgErased
.printsize ArgErased
.decl ArgFVar   (argId: Hash, fvarId: FVarId) choice-domain (argId)
.input ArgFVar
.printsize ArgFVar
.decl ArgType   (argId: Hash, typeId: Hash) choice-domain (argId)
.input ArgType
.printsize ArgType

// Decl
.decl Decl (declId: Name, typeId: Hash, moduleName: Name) choice-domain (declId)
.input Decl
.printsize Decl
.decl DeclParam (declId: Name, paramId: Hash)
.input DeclParam
.printsize DeclParam

// .decl Code (declName: Name, codeId: Hash, ctor: symbol) choice-domain (declId, codeId)
.decl Let              (declId: Name, codeId: Hash, fvarId: FVarId, binderName: Name, typeId: Hash, nextCodeId: Hash) choice-domain (declId, codeId)
.input Let
.printsize Let
.decl LetValueNat      (declId: Name, letCodeId: Hash, value: NatStr) choice-domain (declId, letCodeId)
.input LetValueNat
.printsize LetValueNat
.decl LetValueStr      (declId: Name, letCodeId: Hash, value: symbol) choice-domain (declId, letCodeId)
.input LetValueStr
.printsize LetValueStr
.decl LetValueErased   (declId: Name, letCodeId: Hash) choice-domain (declId, letCodeId)
.input LetValueErased
.printsize LetValueErased
.decl LetValueProj     (declId: Name, letCodeId: Hash, typeName: Name, idx: Nat, struct: FVarId) choice-domain (declId, letCodeId)
.input LetValueProj
.printsize LetValueProj
.decl LetValueConst    (declId: Name, letCodeId: Hash, declName: Name) choice-domain (declId, letCodeId)
.input LetValueConst
.printsize LetValueConst
.decl LetValueConstArg (declId: Name, letCodeId: Hash, argId: Hash) choice-domain (declId, letCodeId, argId)
.input LetValueConstArg
.printsize LetValueConstArg
.decl LetValueFVar    (declId: Name, letCodeId: Hash, fvarId: FVarId) choice-domain (declId, letCodeId)
.input LetValueFVar
.printsize LetValueFVar
.decl LetValueFVarArg (declId: Name, letCodeId: Hash, argId: Hash) choice-domain (declId, letCodeId, argId)
.input LetValueFVarArg
.printsize LetValueFVarArg


.decl Fun        (declId: Name, codeId: Hash, fvarId: FVarId, binderName: Name, typeId: Hash, valueId: Hash) choice-domain (declId, codeId)
.input Fun
.printsize Fun
.decl FunParam   (declId: Name, codeId: Hash, paramId: Hash)
.input FunParam
.printsize FunParam
.decl Jp         (declId: Name, codeId: Hash, fvarId: FVarId, binderName: Name, typeId: Hash, valueId: Hash) choice-domain (declId, codeId)
.input Jp
.printsize Jp
.decl JpParam    (declId: Name, codeId: Hash, paramId: Hash)
.input JpParam
.printsize JpParam
.decl Jmp        (declId: Name, codeId: Hash, fvarId: FVarId) choice-domain (declId, codeId)
.input Jmp
.printsize Jmp
.decl Cases      (declId: Name, codeId: Hash, typeName: Name, resultTypeId: Hash, disc: FVarId) choice-domain (declId, codeId)
.input Cases
.printsize Cases
.decl Return     (declId: Name, codeId: Hash, fvarId: FVarId) choice-domain (declId, codeId)
.input Return
.printsize Return
.decl Unreach    (declId: Name, codeId: Hash, typeId: Hash) choice-domain (declId, codeId)
.input Unreach
.printsize Unreach

// Cases' Alt
.decl Alt        (declId: Name, casesCodeId: Hash, altId: Hash, ctorName: Name) choice-domain (declId, casesCodeId, altId)
.input Alt
.printsize Alt
.decl AltParam   (declId: Name, casesCodeId: Hash, altId: Hash, paramId: Hash)
.input AltParam
.printsize AltParam

.decl AltDefault (declId: Name, casesCodeId: Hash, altId: Hash, next: Hash) choice-domain (declId, casesCodeId, altId)
.input AltDefault
.printsize AltDefault


// RECURSIVE LET
.decl RecursiveLet(declName: Name, codeId: Hash, fvarId: FVarId, binderName: Name, nextId: Hash)
.printsize RecursiveLet

RecursiveLet(declName, codeId, fvarId, binderName, nextCodeId) :-
    Let(declName, codeId, fvarId, binderName, _, nextCodeId),
        LetValueConst(declName, codeId, declName).

// TAIL CALL
.decl TailCall(declName:Name, binderName:Name)
.printsize TailCall

TailCall(declName, binderName) :-
    RecursiveLet(declName, _, fvarId, binderName, codeId),
    Return(declName, codeId, fvarId).

// TAIL CALL MODULE CONS
// Case 1:
// ------
// def List.length._redArg x.1 : Nat :=
//   cases x.1 : Nat
//   | List.nil =>
//     let _x.2 := 0;
//     return _x.2
//   | List.cons head.3 tail.4 =>
//     let _x.5 := List.length._redArg tail.4; -- this is not right before the constructor, but in same block
//     let _x.6 := 1;
//     let _x.7 := Nat.add _x.5 _x.6;
//     return _x.7
// Case 2:
// ------
// def Nat.repeat._redArg f x.1 x.2 : lcErased :=
//   cases x.1 : lcErased
//   | Nat.zero =>
//     return x.2
//   | Nat.succ n.3 =>
//     let _x.4 := Nat.repeat._redArg f n.3 x.2; -- recursive call behind a LetValue.fvar
//     let _x.5 := f _x.4;
//     return _x.5
// Case 3:
// ------
// @[specialize] def any (f : Nat → Bool) : Nat → Bool
//   | 0      => false
//   | succ n => any f n || f n
//
// def Nat.any f x.1 : Bool :=
//   cases x.1 : Bool
//   | Nat.zero =>
//     let _x.2 := false;
//     return _x.2
//   | Nat.succ n.3 =>
//     let _x.4 := any f n.3;
//     cases _x.4 : Bool
//     | Bool.false =>
//       let _x.5 := f n.3;
//       return _x.5
//     | Bool.true =>
//       return _x.4

.decl TailCallModCons(declName:Name, binderName:Name)
.printsize TailCallModCons

TailCallModCons(declName, binderName) :-
    RecursiveLet(declName, _, fvarId, binderName, _),
    Let(declName, ctorCodeId, retFVarId, _, _, retCodeId),
        LetValueConst(declName, ctorCodeId, _),
        LetValueConstArg(declName, ctorCodeId, argId),
        ArgFVar(argId, fvarId),
    Return(declName, retCodeId, retFVarId).

TailCallModCons(declName, binderName) :-
    RecursiveLet(declName, _, fvarId, binderName, _),
    Let(declName, fvarCodeId, retFVarId, _, _, retCodeId),
        LetValueFVar(declName, fvarCodeId, _),
        LetValueFVarArg(declName, fvarCodeId, argId),
        ArgFVar(argId, fvarId),
    Return(declName, retCodeId, retFVarId).

// Find two declarations that are mutual recursive
.decl MutualRecursion(firstDecl:Name, secondDecl: Name)
.printsize MutualRecursion

MutualRecursion(leftDecl,rightDecl) :-
    Let(leftDecl, leftCodeId, _, _, _, _),
        LetValueConst(leftDecl, leftCodeId, rightDecl),
    Let(rightDecl, rightCodeId, _, _, _, _),
        LetValueConst(rightDecl, rightCodeId, leftDecl),
    leftDecl != rightDecl,
    leftCodeId > rightCodeId.


// MAYBE A TAIL CALL (with source code changes)?
.decl MaybeTailCall(declName: Name, binderName: Name)
.printsize MaybeTailCall

MaybeTailCall(declName, binderName) :-
    RecursiveLet(declName, _, _, binderName, _),
    !TailCall(declName, binderName),
    !TailCallModCons(declName, binderName).

// //
// .decl RootDecl(decl: Name)
// .printsize RootDecl

// RootDecl(to) :-
//     Decl(to, _, _),
//     !Call(_, to).

// .decl Call(fromDecl: Name, toDecl: Name)
// .printsize Call

// Call(from, to) :-
//     LetValueConst(from, _, to),
//     from != to.

// OUPUTS
// .output RootDecl
// .output Call
.output TailCallModCons //(delimiter=",")
.output TailCall //(delimiter=",")
.output MaybeTailCall //(delimiter=",")
.output MutualRecursion //(delimiter=",")
