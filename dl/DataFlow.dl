#include "LeanLCNF.dl"

// // path
// .decl Edge(n: symbol, m: symbol)
// .decl Path(n: symbol, m: symbol)

// Path(x,x).
// Path(x,z) :- Path(x,y), Edge(y,z).

// // scc (stongly connected component)
// .decl SCC(n1:symbol, n2:symbol)

// SCC(n1,n2) :- Path(n1,n2), Path(n2,n1).
// SCC(n1,n2) :- Path(n1,n3), Path(n3,n2),
//               Path(n2,n4), Path(n4,n1).

// Dataflow analysis
// OUT[n] = (IN[n] - KILL[n]) U GEN[n]
// IN[n] = U OUT[n'] where n' in predecessors of n

.type N = symbol // set of all program points
.type D = symbol // set of all definition in the given control flow graph

// Input relations
.decl Kill(n:N, d:D) // definition 'd' is killed by statement 'n'
    // Kill == ?? No mutation in Lean?
.decl Gen(n:N, d:D)  // definition 'd' is generated by statement 'n' (variable definitions)
    // Gen == Let
.decl Next(n:N, m:N) // Statement 'm' is an immediate successor of statement 'n' (its the edge in the control graph)
    // Next == Fun, Jp, Cases, Alt, AltDefault
// Output relations
.decl In(n:N, d:D)   // definition 'd' may reach the program point just before statement 'n'
    // This is the reachability edge from the variable definition to the program point
.decl Out(n:N, d:D)  // definition 'd' may reach the program point just after statement 'n'
    //
// Rules
Out(n, d) :- Gen(n, d).
Out(n, d) :- In(n, d), !Kill(n, d).

In(m, d) :- Out(n, d), Next(n, m).

// Live Variables Analysis
// in and out have swapped places
In(n, v) :- Gen(n, v).
In(n, v) :- Out(n, v), !Kill(n, v).
Out(n, v) :- In(m, v), Next(n, v).


// // Pointer analysis (Intra procedural)
// // -----------------------------------
// // Object allocation, copy assignment, return, call function
// // Input relations
// .decl New(v:V, h:H) // statement: `v = new h`
// .decl Assign(v:V,u:H) // statement: `v = u`

// // Output Relations
// .decl Points(v:V,h:H)

// // Rules
// Points(v,h) :- New(v,h).
// Points(v,h) :- Assign(v,u), Points(u,h).

// // Pointer analysis (Inter procedural)
// // -----------------------------------
// // with function calls and returns: parameter passing and return can be treated as assignment
// // E.g.:
// // x = new h1
// // y = f(x)
// // f(v){
// //   u = v;
// //   return u;
// // }
// // here: `v = x`, `u = v` and `y = u`

// // Input relations
// .decl New(v:V, h:H) // statement: `v = new h`
// .decl Assign(v:V,u:H) // statement: `v = u`

// // Output Relations
// .decl Points(v:V,h:H)

// // Rules
// Points(v,h) :- New(v,h).
// Points(v,h) :- Assign(v,u), Points(u,h).

// .decl Arg(f:F, v:V)
// .decl Ret(f:F, u:V)
// .decl Call(y:V, f:F, x:V)

// // Rules
// Points(v,h) :- Call(_, f, x), Arg(f,v), Points(x,h). // parameter assignment rule
// Points(y,h) :- Call(y, f, _), Ret(f,u), Points(u,h). // return assignment rule

// // Must not alias
// // --------------
// MayAlias(u, v) :- Points(u, h), Points(v, h).
// MustNotAlias(u, v) :- !MayAlias(u,v).


// Context sensitivity
//
